Version 1.0
===========

Here is a sample profile for Version 1.0 of Straylight.

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 20.38      3.61     3.61 885016084     0.00     0.00  Matrix<double>::getValue(int, int) const
 14.28      6.14     2.53 107467928     0.00     0.00  Matrix<double>::allocateMatrix()
 10.72      8.04     1.90 539006266     0.00     0.00  Matrix<double>::setValue(int, int, double)
  9.62      9.75     1.71 859144515     0.00     0.00  Matrix<double>::getRowCount() const
  8.81     11.31     1.56 1240371610     0.00     0.00  Matrix<double>::getColumnCount() const
  7.25     12.59     1.29 56932493     0.00     0.00  Matrix<double>::Matrix(Matrix<double> const&)
  3.10     13.14     0.55 86880178     0.00     0.00  Matrix<double>::~Matrix()
  1.81     13.46     0.32 16149339     0.00     0.00  Matrix<double>::operator-(Matrix<double> const&) const

We can see that program execution time is dominated by Matrix
operations. getValue(), allocateMatrix() and setValue() will likely need
to be retained in some form since vectors will need their values changed
and memory allocated for them, but perhaps this can be done in a simpler
way.

getRowCount(), getColumnCount() and the contructor and destructor can be
eliminated.

Together, these account for 74.16% of the running time! They are therefore
the largest performance culprits. For version 1.1 an attempt will be made
to create a small and fast Vector3 class that does not depend on Matrices.
Since Vectors are small and are created on the fly and not stored, the
program will switch to storing them on the stack, rather than on the heap.


Version 1.1
===========

The switch to a simpler vector class had the desired effect. Dropping
execution time by a factor of 11x, measured by the execution times of
the 2048x2048 test run.

359.09 / 30.87 = 11.63

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
 11.63      0.73     0.73 154124159     0.00     0.00  SimpleVector::dot(SimpleVector const&) const
  8.92      1.29     0.56 35342554     0.00     0.00  Sphere::testIntersection(Ray&) const
  8.28      1.81     0.52 201068945     0.00     0.00  SimpleVector::SimpleVector(double, double, double)
  6.69      2.23     0.42 126480463     0.00     0.00  SimpleVector::SimpleVector(SimpleVector const&)
  6.05      2.61     0.38 12305144     0.00     0.00  Scene::testIntersection(Ray&)
  5.89      2.98     0.37 39558044     0.00     0.00  SimpleVector::getMagnitude() const
  4.62      3.27     0.29  4363008     0.00     0.00  Light::getGlobalLightAt(Ray&, SimpleVector const&)
  4.14      3.53     0.26 60736723     0.00     0.00  SimpleVector::operator-(SimpleVector const&) const
  3.82      3.77     0.24 68597247     0.00     0.00  SimpleVector::operator*(double) const

Most of the time is now spent in the dot operator. This seems curious,
but it is part of Sphere::testIntersection which is at least the second
highest time now Sphere::testIntersection, which is as it should be.

There still seems to be way too much time spent on Vector constructors
and copy constructors. There may be more work to do to optimize the
Vector class.

It's likely that because the Vectors are stored on the stack and are
constantly being copied into and out of functions these constructors are
taking so much time.

For the next major version it would be more advantageous to explore a
threading solution. This is after the minor change of adding a Colour
class.


Version 1.1.1
=============

This version added a Colour class to replace the use of Vectors to store
Colour values.

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
  9.25      0.66     0.66 154124159     0.00     0.00  SimpleVector::dot(SimpleVector const&) const
  7.49      1.19     0.53 104712192     0.00     0.00  Colour::get(int) const
  7.06      1.69     0.50 188230238     0.00     0.00  SimpleVector::SimpleVector(double, double, double)
  6.78      2.17     0.48 122286159     0.00     0.00  SimpleVector::SimpleVector(SimpleVector const&)
  6.22      2.61     0.44 35342554     0.00     0.00  Sphere::testIntersection(Ray&) const
  5.93      3.03     0.42 39558044     0.00     0.00  SimpleVector::getMagnitude() const
  5.79      3.44     0.41 12305144     0.00     0.00  Scene::testIntersection(Ray&)
  5.51      3.83     0.39  4363008     0.00     0.00  Light::getGlobalLightAt(Ray&, SimpleVector const&)
  4.24      4.13     0.30 39558044     0.00     0.00  SimpleVector::operator/(double) const
  3.96      4.41     0.28 68597247     0.00     0.00  SimpleVector::operator*(do

The addition results in even more OOP-related overhead. This project
may benefit greatly from the eradication of getters and setters and some
way to prevent the ubiquotous copying.


Version 1.1.2
=============

This version cleaned up the code a little, taking out some superfluous
getters and setters and presumably eliminating a lot of copying.

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls   s/call   s/call  name    
  9.83      0.61     0.61 104712192     0.00     0.00  Colour::get(int) const
  9.58      1.21     0.60 154124159     0.00     0.00  SimpleVector::dot(SimpleVector const&) const
  7.41      1.67     0.46 188230238     0.00     0.00  SimpleVector::SimpleVector(double, double, double)
  7.01      2.10     0.44 39558044     0.00     0.00  SimpleVector::getMagnitude() const
  6.28      2.49     0.39  4363008     0.00     0.00  Light::getGlobalLightAt(Ray&, SimpleVector const&)
  6.12      2.87     0.38 12305144     0.00     0.00  Scene::testIntersection(Ray&)
  4.91      3.18     0.31 39558044     0.00     0.00  SimpleVector::operator/(double) const
  4.67      3.47     0.29 35342554     0.00     0.00  Sphere::testIntersection(Ray&) const
  3.87      3.71     0.24 70121497     0.00     0.00  SimpleVector::SimpleVector(SimpleVector const&)
  3.87      3.95     0.24 68597247     0.00     0.00  SimpleVector::operator*(do:

Colour::get takes up more % of time, although it's absolute time is
down. Vector dot product and copy still take a lot of time, as does
getting magnitude. Perhaps there is some superfluous normalisation going
on? testIntersection may be too low, or the scene may be pretty simple.

All in all there's no glaringly obvious things to remove, as most take
about 0.6 seconds. The scene should be made larger so we have some more
data in terms of time. There's also the problem that this scene isn't
really representative because of its simplicity. The program would
benefit much more from threading at the moment.

Negligable performance improvements here. The OOP changes were made for 
the sake of simplicity though, so no harm done there.


Version 1.2
===========

This version added multithreading to Straylight. The image was divided into
four y-bands and work was distributed to each core on a quad core CPU.

Each sample counts as 0.01 seconds.
  %   cumulative   self              self     total           
 time   seconds   seconds    calls  ms/call  ms/call  name    
 22.46      1.61     1.61 85048393     0.00     0.00  Camera::getRayAt(int, int)
 12.70      2.52     0.91 31703973     0.00     0.00  Sphere::testIntersection(Ray&) const
 12.28      3.40     0.88  3112989     0.00     0.00  loadScene()
  6.42      3.86     0.46 55219949     0.00     0.00  parseArguments(int, char**)
  6.14      4.30     0.44 10449333     0.00     0.00  Light::getGlobalLightAt(Ray&, SimpleVector const&)
  5.72      4.71     0.41 48794013     0.00     0.00  Camera::Camera(SimpleVector, SimpleVector, SimpleVector)
  4.60      5.04     0.33 25715520     0.00     0.00  SimpleVector::cross(SimpleVector const&) const
  3.49      5.29     0.25                             shootRay(Ray&)
  3.35      5.53     0.24  1039233     0.00     0.00  SimpleVector::operator/(double) const
  2.93      5.74     0.21                             Ray::Ray(SimpleVector const&, SimpleVector const&)
  2.79      5.94     0.20                             Light::Light()
  2.23      6.10     0.16                             Camera::Camera(SimpleVector, SimpleVector, SimpleVector)
  1.95      6.24     0.14       34     4.12    48.46  _fini
  1.67      6.36     0.12  3256709     0.00     0.00  shootShadowRay(Ray&)
  1.67      6.48     0.12  4266589     0.00     0.00  castRays()
  1.40      6.58     0.10                             Light::Light()
  1.12      6.66     0.08  7525277     0.00     0.00  Colour::set(int, double)

Interestingly, the debug version that's used to produce this call graph
shows a significant *increase* in the amount of time the ray tracer spent
creating an image - even though the work has been distributed among four
CPU cores.

39.90 / 29.75 = 1.35 times *increase* in time taken.

However, the optimized build shows a different story. A quick run over
2048x2048 pixels shows:

4.89 / 2.06 = 2.37 times decrease in time taken.

This makes more sense, however it's still not the 4x speed increase that's
expected given the parallel nature of ray tracing.

A likely culprit is imperfect load balancing. As mentioned before, the scene is
simply divided into four bands. If one band is less complex than the other, the
thread that is computing it will terminate long before the others, leaving a
core idle.

This should be addressed in the next version with a better multithreading
algorithm.


Version 2
=========

This version adds several fixes, new features and NFF file parsing. A recon-
struction of the old scene in the NFF file format renders in 6 seconds
unoptimized on 2048x2048 pixels. Optimized runs take only 2.5 seconds.

Note that this is not a perfect reconstruction and as such cannot be used to
compare performance exactly. Given the small performance delta and the number
of variables changed, no conclusion can be drawn from these measurements.

A bigger scene is now required to gather sufficient data. The ray tracer was
run over 1024x1024 pixels on the "Spherflake" scene from the SPD (unoptimized).

The run took 47m25.520s real time, 160m45.650s user time and 0m0.040s system
time.

